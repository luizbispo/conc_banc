# modules/report_generator.py
import pandas as pd
import numpy as np
from datetime import datetime
from fpdf import FPDF
import tempfile
import os
from typing import List, Dict, Any

class PDFReport(FPDF):
    def __init__(self):
        super().__init__()
        self.set_auto_page_break(auto=True, margin=15)
        self.add_page()
        
    def header(self):
        self.set_font('Arial', 'B', 16)
        self.cell(0, 40, 'RELAT√ìRIO DE CONCILIA√á√ÉO BANC√ÅRIA', 0, 1, 'C')
        self.set_font('Arial', 'I', 10)
        self.cell(0, 5, f'Gerado em: {datetime.now().strftime("%d/%m/%Y %H:%M")}', 0, 1, 'C')
        self.ln(5)
    
    def footer(self):
        self.set_y(-15)
        self.set_font('Arial', 'I', 8)
        self.cell(0, 10, f'P√°gina {self.page_no()}', 0, 0, 'C')
    
    def chapter_title(self, title):
        self.set_font('Arial', 'B', 14)
        self.cell(0, 10, self.clean_text(title), 0, 1, 'L')
        self.ln(2)

    def chapter_body(self, body):
        self.set_font('Arial', '', 10)
        cleaned_body = self.clean_text(body)
        self.multi_cell(0, 6, cleaned_body)
        self.ln()
    
    def clean_text(self, text):
        if not text:
            return ""
        
        text = str(text)
        
        replacements = {
            '‚úÖ': '[OK]', '‚úî': '[OK]', '‚úì': '[OK]', '‚òë': '[OK]',
            '‚ùå': '[ERRO]', '‚úñ': '[ERRO]', '‚ùé': '[ERRO]',
            '‚ö†': '[ATENCAO]', '‚ö°': '[RAPIDO]', 'üéØ': '[FOCO]',
            'üìä': '[METRICAS]', 'üìã': '[RELATORIO]', 'üîç': '[ANALISE]',
            'üí°': '[DICA]', 'üöÄ': '[RAPIDO]', '‚≠ê': '[DESTAQUE]',
            '‚Ä¢': '-', '¬∑': '-', '‚Äì': '-', '‚Äî': '-', '‚Ä£': '-', '‚ÅÉ': '-',
            '‚Äú': '"', '‚Äù': '"', '‚Äò': "'", '‚Äô': "'", '¬¥': "'", '`': "'",
        }
        
        for old_char, new_char in replacements.items():
            text = text.replace(old_char, new_char)
        
        try:
            text = text.encode('latin-1', 'replace').decode('latin-1')
        except:
            pass
        
        return text
    
def gerar_relatorio_analise(resultados_analise: Dict,
                          extrato_df: pd.DataFrame,
                          contabil_df: pd.DataFrame,
                          empresa_nome: str = "Empresa",
                          contador_nome: str = "Contador",
                          periodo: str = "",
                          observacoes: str = "",
                          formato: str = "completo",
                          divergencias_tabela: pd.DataFrame = None,
                          **kwargs) -> str:
    """
    Gera relat√≥rio de an√°lise (n√£o de concilia√ß√£o)
    formato: 'completo' ou 'resumido'
    """
    pdf = PDFReport()
    
    # P√°gina 1: Capa (comum para ambos os formatos)
    pdf.add_page()
    pdf.set_font('Arial', 'B', 20)
    pdf.cell(0, 40, 'RELAT√ìRIO DE AN√ÅLISE DE CORRESPOND√äNCIAS', 0, 1, 'C')
    pdf.set_font('Arial', 'B', 16)
    pdf.cell(0, 20, pdf.clean_text(empresa_nome), 0, 1, 'C')
    pdf.set_font('Arial', '', 12)
    pdf.cell(0, 10, f'Per√≠odo: {periodo}', 0, 1, 'C')
    pdf.cell(0, 10, f'Analista: {pdf.clean_text(contador_nome)}', 0, 1, 'C')
    pdf.cell(0, 10, f'Data de gera√ß√£o: {datetime.now().strftime("%d/%m/%Y")}', 0, 1, 'C')
    pdf.cell(0, 10, f'Formato: {formato.upper()}', 0, 1, 'C')
    
    pdf.ln(20)
    
    # Sum√°rio Executivo (comum para ambos os formatos)
    pdf.chapter_title('RELAT√ìRIO DE AN√ÅLISE - CORRESPOND√äNCIAS IDENTIFICADAS')
    
    total_matches = len(resultados_analise['matches'])
    total_excecoes = len(resultados_analise.get('excecoes', []))
    total_extrato = len(extrato_df)
    total_contabil = len(contabil_df)
    
    resumo_texto = f"""
    ESTE √â UM RELAT√ìRIO DE AN√ÅLISE E IDENTIFICA√á√ÉO DE CORRESPOND√äNCIAS
    
    OBJETIVO:
    Identificar automaticamente rela√ß√µes entre transa√ß√µes banc√°rias e lan√ßamentos cont√°beis
    para auxiliar no processo de concilia√ß√£o manual.
    
    RESULTADOS DA AN√ÅLISE:
    - Transa√ß√µes banc√°rias analisadas: {total_extrato}
    - Lan√ßamentos cont√°beis analisados: {total_contabil}
    - Correspond√™ncias identificadas: {total_matches}
    - Diverg√™ncias encontradas: {total_excecoes}
    - Per√≠odo analisado: {periodo}
    
    METODOLOGIA:
    An√°lise em tr√™s camadas:
    1. CORRESPOND√äNCIAS EXATAS: Valores e datas id√™nticos, identificadores √∫nicos
    2. CORRESPOND√äNCIAS POR SIMILARIDADE: Valores e datas pr√≥ximos, textos similares  
    3. AN√ÅLISE DE PADR√ïES: Parcelamentos, consolida√ß√µes, padr√µes temporais
    
    OBSERVA√á√ïES:
    {observacoes if observacoes else 'Nenhuma observa√ß√£o adicional'}
    
    ATEN√á√ÉO: Este relat√≥rio apresenta CORRESPOND√äNCIAS IDENTIFICADAS que devem ser validadas 
    manualmente pelo contador antes da concilia√ß√£o final.
    """
    
    pdf.chapter_body(resumo_texto)
    
    # P√°gina 2: Estat√≠sticas (comum para ambos os formatos)
    pdf.add_page()
    pdf.chapter_title('ESTAT√çSTICAS DETALHADAS')
    
    # M√©tricas principais
    pdf.set_font('Arial', 'B', 12)
    pdf.cell(0, 10, 'M√âTRICAS PRINCIPAIS:', 0, 1)
    pdf.set_font('Arial', '', 10)
    
    taxa_cobertura = (total_matches / total_extrato * 100) if total_extrato > 0 else 0
    valor_total_extrato_absoluto = extrato_df['valor'].abs().sum()
    valor_total_extrato = extrato_df['valor'].sum()
    valor_total_contabil = contabil_df['valor'].sum()
    
    estatisticas_texto = f"""
    VOLUME DE DADOS:
    - Transa√ß√µes banc√°rias: {total_extrato}
    - Lan√ßamentos cont√°beis: {total_contabil}
    - Valor total extrato (absoluto): R$ {valor_total_extrato_absoluto:,.2f}
    - Valor total extrato: R$ {valor_total_extrato:,.2f}
    - Valor total cont√°bil: R$ {valor_total_contabil:,.2f}
    
    RESULTADOS DA IDENTIFICA√á√ÉO:
    - Correspond√™ncias identificadas: {total_matches}
    - Taxa de cobertura: {taxa_cobertura:.1f}%
    - Diverg√™ncias: {total_excecoes}
    
    DISTRIBUI√á√ÉO POR TIPO:
    - Correspond√™ncias 1:1: {len([m for m in resultados_analise['matches'] if m['tipo_match'] == '1:1'])}
    - Correspond√™ncias 1:N: {len([m for m in resultados_analise['matches'] if m['tipo_match'] == '1:N'])}
    - Correspond√™ncias N:1: {len([m for m in resultados_analise['matches'] if m['tipo_match'] == 'N:1'])}
    
    EFETIVIDADE POR CAMADA:
    - Correspond√™ncias exatas: {len([m for m in resultados_analise['matches'] if m['camada'] == 'exata'])}
    - Correspond√™ncias por similaridade: {len([m for m in resultados_analise['matches'] if m['camada'] == 'heuristica'])}
    - Correspond√™ncias complexas: {len([m for m in resultados_analise['matches'] if m['camada'] == 'ia'])}
    """
    
    pdf.chapter_body(estatisticas_texto)
    
    # CONTE√öDO ESPEC√çFICO PARA RELAT√ìRIO COMPLETO
    if formato == 'completo':
        # P√°gina 3: Correspond√™ncias Identificadas (apenas no completo)
        if resultados_analise['matches']:
            pdf.add_page()
            pdf.chapter_title('CORRESPOND√äNCIAS IDENTIFICADAS - DETALHES COMPLETOS')
            
            headers = ['ID', 'Tipo', 'Camada', 'Confian√ßa', 'Valor Total', 'Trans Bank', 'Lanc Cont']
            col_widths = [10, 20, 25, 20, 30, 20, 20]
            
            pdf.set_font('Arial', 'B', 8)
            for i, header in enumerate(headers):
                pdf.cell(col_widths[i], 8, header, 1, 0, 'C')
            pdf.ln()
            
            pdf.set_font('Arial', '', 7)
            for i, match in enumerate(resultados_analise['matches']):
                pdf.cell(col_widths[0], 6, str(i + 1), 1, 0, 'C')
                pdf.cell(col_widths[1], 6, match['tipo_match'], 1, 0, 'C')
                pdf.cell(col_widths[2], 6, match['camada'], 1, 0, 'C')
                pdf.cell(col_widths[3], 6, f"{match['confianca']}%", 1, 0, 'C')
                pdf.cell(col_widths[4], 6, f"R$ {match['valor_total']:.2f}", 1, 0, 'C')
                pdf.cell(col_widths[5], 6, str(len(match['ids_extrato'])), 1, 0, 'C')
                pdf.cell(col_widths[6], 6, str(len(match['ids_contabil'])), 1, 0, 'C')
                pdf.ln()
            
            pdf.ln(10)
            pdf.chapter_title('PRINCIPAIS CORRESPOND√äNCIAS - DETALHES')
            
            for i, match in enumerate(resultados_analise['matches'][:10]):  # Limitar a 10 no completo
                pdf.set_font('Arial', 'B', 9)
                pdf.cell(0, 8, f'Correspond√™ncia {i + 1}: {match["tipo_match"]} - {match["camada"]}', 0, 1)
                pdf.set_font('Arial', '', 8)
                pdf.multi_cell(0, 4, f'Justificativa: {pdf.clean_text(match["explicacao"])}')
                pdf.multi_cell(0, 4, f'Valor: R$ {match["valor_total"]:.2f} | Confian√ßa: {match["confianca"]}%')
                
                transacoes_extrato = extrato_df[extrato_df['id'].isin(match['ids_extrato'])]
                transacoes_contabil = contabil_df[contabil_df['id'].isin(match['ids_contabil'])]
                
                pdf.multi_cell(0, 4, f'Transa√ß√µes banc√°rias: {len(transacoes_extrato)}')
                for _, trans in transacoes_extrato.iterrows():
                    data_str = trans['data'].strftime('%d/%m') if hasattr(trans['data'], 'strftime') else str(trans['data'])
                    valor_original = trans.get('valor_original', trans['valor'])
                    pdf.multi_cell(0, 3, f'  - R$ {valor_original:,.2f} | {data_str} | {pdf.clean_text(trans["descricao"][:30])}')
                
                pdf.multi_cell(0, 4, f'Lan√ßamentos cont√°beis: {len(transacoes_contabil)}')
                for _, lanc in transacoes_contabil.iterrows():
                    data_str = lanc['data'].strftime('%d/%m') if hasattr(lanc['data'], 'strftime') else str(lanc['data'])
                    valor_original = lanc.get('valor_original', lanc['valor'])
                    pdf.multi_cell(0, 3, f'  - R$ {valor_original:,.2f} | {data_str} | {pdf.clean_text(lanc["descricao"][:30])}')
                
                pdf.ln(5)
    
    else:  # RELAT√ìRIO RESUMIDO
        # P√°gina 3: Correspond√™ncias Resumidas
        if resultados_analise['matches']:
            pdf.add_page()
            pdf.chapter_title('CORRESPOND√äNCIAS IDENTIFICADAS - VIS√ÉO RESUMIDA')
            
            pdf.set_font('Arial', '', 9)
            pdf.multi_cell(0, 5, f'Total de correspond√™ncias identificadas: {len(resultados_analise["matches"])}')
            
            # Apenas estat√≠sticas resumidas no relat√≥rio resumido
            tipos_match = {
                '1:1': len([m for m in resultados_analise['matches'] if m['tipo_match'] == '1:1']),
                '1:N': len([m for m in resultados_analise['matches'] if m['tipo_match'] == '1:N']),
                'N:1': len([m for m in resultados_analise['matches'] if m['tipo_match'] == 'N:1'])
            }
            
            pdf.multi_cell(0, 5, f'Distribui√ß√£o: 1:1 ({tipos_match["1:1"]}), 1:N ({tipos_match["1:N"]}), N:1 ({tipos_match["N:1"]})')
            
            # Apenas as 3 principais correspond√™ncias por confian√ßa
            matches_ordenados = sorted(resultados_analise['matches'], key=lambda x: x['confianca'], reverse=True)[:3]
            
            if matches_ordenados:
                pdf.ln(5)
                pdf.set_font('Arial', 'B', 10)
                pdf.cell(0, 8, 'PRINCIPAIS CORRESPOND√äNCIAS (TOP 3):', 0, 1)
                
                for i, match in enumerate(matches_ordenados):
                    pdf.set_font('Arial', 'B', 9)
                    pdf.cell(0, 6, f'{i+1}. {match["tipo_match"]} - Confian√ßa: {match["confianca"]}% - Valor: R$ {match["valor_total"]:.2f}', 0, 1)
                    pdf.set_font('Arial', '', 8)
                    pdf.multi_cell(0, 4, f'   {pdf.clean_text(match["explicacao"][:100])}...')
                    pdf.ln(2)
    
    # P√°gina de Diverg√™ncias (comum mas com detalhamento diferente)
    if resultados_analise.get('excecoes'):
        pdf.add_page()
        
        if formato == 'completo':
            pdf.chapter_title('DIVERG√äNCIAS IDENTIFICADAS - AN√ÅLISE COMPLETA')
        else:
            pdf.chapter_title('DIVERG√äNCIAS IDENTIFICADAS - RESUMO')
        
        for i, excecao in enumerate(resultados_analise['excecoes']):
            pdf.set_font('Arial', 'B', 10)
            pdf.cell(0, 8, f'Diverg√™ncia {i + 1}: {excecao["tipo"]} - {excecao["severidade"]}', 0, 1)
            pdf.set_font('Arial', '', 9)
            pdf.multi_cell(0, 5, f'Descri√ß√£o: {pdf.clean_text(excecao["descricao"])}')
            pdf.multi_cell(0, 5, f'Recomenda√ß√£o: {pdf.clean_text(excecao["acao_sugerida"])}')
            pdf.multi_cell(0, 5, f'Itens envolvidos: {len(excecao["ids_envolvidos"])}')
            pdf.ln(5)
    
    # Tabela de Diverg√™ncias Detalhadas (APENAS NO COMPLETO)
    if formato == 'completo' and divergencias_tabela is not None and not divergencias_tabela.empty:
        try:
            pdf.add_page()
            pdf.chapter_title('TABELA DETALHADA DE DIVERG√äNCIAS')
            
            headers = ['Tipo', 'Severidade', 'Data', 'Descri√ß√£o', 'Valor', 'Origem']
            col_widths = [15, 20, 20, 60, 25, 20]
            
            pdf.set_font('Arial', 'B', 8)
            for i, header in enumerate(headers):
                pdf.cell(col_widths[i], 8, header, 1, 0, 'C')
            pdf.ln()
            
            def abreviar_tipo_divergencia(tipo_original):
                abreviacoes = {
                    'TRANSA√á√ÉO_SEM_CORRESPOND√äNCIA': 'TSC',
                    'LAN√áAMENTO_SEM_CORRESPOND√äNCIA': 'LSC',
                    'TRANSA√á√ÉO_SEM_CORRESPONDENCIA': 'TSC',
                    'LAN√áAMENTO_SEM_CORRESPONDENCIA': 'LSC'
                }
                return abreviacoes.get(tipo_original, tipo_original)
            
            pdf.set_font('Arial', '', 7)
            for _, row in divergencias_tabela.iterrows():
                descricao = str(row.get('Descri√ß√£o', row.get('descricao', '')))[:50] + "..." if len(str(row.get('Descri√ß√£o', row.get('descricao', '')))) > 50 else str(row.get('Descri√ß√£o', row.get('descricao', '')))
                
                tipo_original = str(row.get('Tipo_Diverg√™ncia', row.get('Tipo', '')))
                tipo = abreviar_tipo_divergencia(tipo_original)
                
                severidade = str(row.get('Severidade', ''))
                data = str(row.get('Data', ''))
                valor = str(row.get('Valor', ''))
                origem = str(row.get('Origem', ''))
                
                pdf.cell(col_widths[0], 6, pdf.clean_text(tipo), 1, 0, 'C')
                pdf.cell(col_widths[1], 6, pdf.clean_text(severidade), 1, 0, 'C')
                pdf.cell(col_widths[2], 6, pdf.clean_text(data), 1, 0, 'C')
                pdf.cell(col_widths[3], 6, pdf.clean_text(descricao), 1, 0, 'L')
                pdf.cell(col_widths[4], 6, pdf.clean_text(valor), 1, 0, 'C')
                pdf.cell(col_widths[5], 6, pdf.clean_text(origem), 1, 0, 'C')
                pdf.ln()
            
            pdf.ln(5)
            pdf.set_font('Arial', 'I', 8)
            pdf.cell(0, 6, f'Total de diverg√™ncias detalhadas: {len(divergencias_tabela)}', 0, 1)
            
        except Exception as e:
            print(f"‚ö†Ô∏è Aviso: N√£o foi poss√≠vel adicionar tabela de diverg√™ncias: {e}")
    
    # P√°gina final: Recomenda√ß√µes (comum para ambos)
    pdf.add_page()
    pdf.chapter_title('RECOMENDA√á√ïES E PR√ìXIMOS PASSOS')
    
    if formato == 'completo':
        recomendacoes_texto = """
        RECOMENDA√á√ïES PARA CONCILIA√á√ÉO MANUAL:
        
        1. VALIDAR CORRESPOND√äNCIAS IDENTIFICADAS
           - Confirmar cada correspond√™ncia proposta
           - Verificar se as rela√ß√µes fazem sentido comercial
           - Validar valores e datas
        
        2. INVESTIGAR DIVERG√äNCIAS
           - Analisar transa√ß√µes sem correspond√™ncia (TSC)
           - Verificar lan√ßamentos sem movimento banc√°rio (LSC)
           - Identificar poss√≠veis erros de lan√ßamento
        
        3. AJUSTES NECESS√ÅRIOS
           - Corrigir lan√ßamentos incorretos
           - Incluir transa√ß√µes omitidas
           - Ajustar classifica√ß√µes cont√°beis
        
        4. DOCUMENTA√á√ÉO
           - Manter registro das valida√ß√µes realizadas
           - Documentar ajustes feitos
           - Arquivar este relat√≥rio de an√°lise
        """
    else:
        recomendacoes_texto = """
        PR√ìXIMOS PASSOS RECOMENDADOS:
        
        ‚Ä¢ Validar correspond√™ncias identificadas
        ‚Ä¢ Investigar diverg√™ncias cr√≠ticas
        ‚Ä¢ Ajustar lan√ßamentos conforme necess√°rio
        ‚Ä¢ Documentar processo de concilia√ß√£o
        
        PARA AN√ÅLISE DETALHADA:
        Consulte o relat√≥rio completo para:
        - Tabelas detalhadas de correspond√™ncias
        - An√°lise completa de diverg√™ncias
        - Detalhes t√©cnicos da an√°lise
        """
    
    recomendacoes_texto += """
    
    OBSERVA√á√ïES IMPORTANTES:
    - Este relat√≥rio √© uma FERRAMENTA DE AUX√çLIO
    - Todas as correspond√™ncias devem ser VALIDADAS MANUALMENTE
    - A responsabilidade final pela concilia√ß√£o √© do contador
    - Mantenha documenta√ß√£o adequada para auditoria
    """
    
    pdf.chapter_body(recomendacoes_texto)
    pdf.add_page()
    
    # Assinatura
    pdf.ln(15)
    pdf.set_font('Arial', '', 10)
    pdf.cell(0, 8, '_________________________', 0, 1, 'C')
    pdf.cell(0, 8, pdf.clean_text(contador_nome), 0, 1, 'C')
    pdf.cell(0, 8, 'Contador Respons√°vel', 0, 1, 'C')
    
    # Salvar PDF
    temp_dir = tempfile.gettempdir()
    pdf_path = os.path.join(temp_dir, f'relatorio_analise_{formato}_{datetime.now().strftime("%Y%m%d_%H%M%S")}.pdf')
    
    try:
        pdf.output(pdf_path)
        return pdf_path
    except Exception as e:
        print(f"Erro ao salvar PDF: {e}")
        pdf_path_fallback = os.path.join(temp_dir, f'relatorio_analise_fallback_{datetime.now().strftime("%Y%m%d_%H%M%S")}.pdf')
        pdf.output(pdf_path_fallback)
        return pdf_path_fallback

def _abreviar_tipo_divergencia(self, tipo_original):
    """Abrevia tipos longos de diverg√™ncia para melhor visualiza√ß√£o na tabela"""
    abreviacoes = {
        'TRANSA√á√ÉO_SEM_CORRESPOND√äNCIA': 'TSC',
        'LAN√áAMENTO_SEM_CORRESPOND√äNCIA': 'LSC',
        'TRANSA√á√ÉO_SEM_CORRESPONDENCIA': 'TSC',  # Fallback sem acento
        'LAN√áAMENTO_SEM_CORRESPONDENCIA': 'LSC'  # Fallback sem acento
    }
    return abreviacoes.get(tipo_original, tipo_original)